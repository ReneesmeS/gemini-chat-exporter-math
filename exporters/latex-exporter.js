/**
 * LaTeX Exporter for Gemini Chat Exporter
 * Converts extracted Gemini content to a standalone LaTeX (.tex) document.
 */

export class LatexExporter {
  constructor(data, options = {}) {
    this.data = data;
    this.options = {
      includeTimestamp: true,
      includeMeta: true,
      ...options
    };
  }

  export() {
    const parts = [];

    parts.push(this.generatePreamble());
    parts.push('\\begin{document}\n');

    if (this.options.includeMeta) {
      parts.push(this.generateHeader());
    }

    for (let i = 0; i < this.data.messages.length; i++) {
      const message = this.data.messages[i];
      if (i > 0) {
        parts.push('\n\\noindent\\rule{\\linewidth}{0.4pt}\n\n');
      }
      parts.push(this.processMessage(message));
    }

    parts.push('\n\\end{document}\n');
    return parts.join('');
  }

  generatePreamble() {
    return [
      '% Generated by Gemini Chat Exporter',
      '\\documentclass[11pt]{article}',
      '\\usepackage[margin=1in]{geometry}',
      '\\usepackage[T1]{fontenc}',
      '\\usepackage[utf8]{inputenc}',
      '\\usepackage{hyperref}',
      '\\usepackage{amsmath,amssymb}',
      '\\usepackage{enumitem}',
      '\\usepackage{tabularx}',
      '\\usepackage{longtable}',
      '\\usepackage{xcolor}',
      '\\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=blue}',
      '\\setlist{noitemsep}',
      ''
    ].join('\n');
  }

  generateHeader() {
    const { metadata } = this.data;
    const title = metadata.title && metadata.title !== 'Gemini Conversation'
      ? metadata.title
      : 'Gemini Conversation Export';

    const header = [];

    const titleInline = this.parseInlineLatexFromText(title);
    header.push('\\section*{' + this.processInlineContent(titleInline) + '}\n');

    if (this.options.includeTimestamp && metadata.timestamp) {
      header.push('\\textbf{Exported:} ' + this.escapeLatexText(new Date(metadata.timestamp).toLocaleString()) + '\\\\');
      header.push('\n');
    }

    if (metadata.url) {
      header.push('\\textbf{URL:} ' + this.latexHref(metadata.url, metadata.url) + '\\\\');
      header.push('\n');
    }

    if (typeof metadata.messageCount === 'number') {
      header.push('\\textbf{Messages:} ' + this.escapeLatexText(String(metadata.messageCount)) + '\\par\n');
    }

    header.push('\n\\noindent\\rule{\\linewidth}{0.4pt}\n\n');
    return header.join('');
  }

  parseInlineLatexFromText(text) {
    if (text == null) return [{ type: 'text', text: '' }];
    const s = String(text);
    const parts = [];
    let i = 0;

    const pushText = (t) => {
      if (t) parts.push({ type: 'text', text: t });
    };

    while (i < s.length) {
      const nextDollar = s.indexOf('$', i);
      if (nextDollar === -1) {
        pushText(s.slice(i));
        break;
      }

      pushText(s.slice(i, nextDollar));

      // $$...$$ (math-block)
      if (s[nextDollar + 1] === '$') {
        const end = s.indexOf('$$', nextDollar + 2);
        if (end === -1) {
          pushText(s.slice(nextDollar));
          break;
        }
        const latex = s.slice(nextDollar + 2, end);
        parts.push({ type: 'math-block', latex });
        i = end + 2;
        continue;
      }

      // $...$ (math-inline)
      const end = s.indexOf('$', nextDollar + 1);
      if (end === -1) {
        pushText(s.slice(nextDollar));
        break;
      }

      const latex = s.slice(nextDollar + 1, end);
      parts.push({ type: 'math-inline', latex });
      i = end + 1;
    }

    return parts.length ? parts : [{ type: 'text', text: '' }];
  }

  processMessage(message) {
    if (!message || !message.structure) return '';

    const parts = [];
    for (const block of message.structure) {
      parts.push(this.processBlock(block));
    }
    return parts.join('');
  }

  processBlock(block) {
    switch (block.type) {
      case 'paragraph':
        return this.processParagraph(block) + '\n\n';
      case 'heading':
        return this.processHeading(block) + '\n\n';
      case 'unordered-list':
      case 'ordered-list':
        return this.processList(block) + '\n\n';
      case 'blockquote':
        return this.processBlockquote(block) + '\n\n';
      case 'code-block':
        return this.processCodeBlock(block) + '\n\n';
      case 'horizontal-rule':
        return '\\noindent\\rule{\\linewidth}{0.4pt}\n\n';
      case 'table':
        return this.processTable(block) + '\n\n';
      case 'math-block':
        return this.processMathBlock(block) + '\n\n';
      default:
        return block?.text ? this.escapeLatexText(block.text) + '\n\n' : '';
    }
  }

  processParagraph(block) {
    return this.processInlineContent(block.content);
  }

  processHeading(block) {
    const content = this.processInlineContent(block.content);
    const level = Number(block.level) || 1;

    // Map heading levels to LaTeX sectioning.
    if (level <= 1) return `\\section{${content}}`;
    if (level === 2) return `\\subsection{${content}}`;
    if (level === 3) return `\\subsubsection{${content}}`;
    if (level === 4) return `\\paragraph{${content}}`;
    return `\\subparagraph{${content}}`;
  }

  processBlockquote(block) {
    const content = this.processInlineContent(block.content);
    return `\\begin{quote}\n${content}\n\\end{quote}`;
  }

  processCodeBlock(block) {
    const code = (block.code || '').replace(/\r\n/g, '\n');
    return `\\begin{verbatim}\n${code}\n\\end{verbatim}`;
  }

  processMathBlock(block) {
    const latex = (block.latex || '').trim();
    return `\\[\n${latex}\n\\]`;
  }

  processList(block, indent = 0) {
    const isOrdered = block.type === 'ordered-list';
    const env = isOrdered ? 'enumerate' : 'itemize';
    const items = Array.isArray(block.items) ? block.items : [];

    const parts = [];
    parts.push(`\\begin{${env}}`);

    for (const item of items) {
      const { text, mathBlocks } = this.splitInlineContent(item.content);
      const safeText = (text || '').trim();

      if (safeText.length > 0) {
        parts.push(`\\item ${safeText}`);
      } else {
        parts.push('\\item');
      }

      for (const latex of mathBlocks) {
        parts.push(`\\[\n${latex}\n\\]`);
      }

      if (item.nested && Array.isArray(item.nested) && item.nested.length > 0) {
        const nestedBlock = {
          type: item.nestedType === 'ordered' ? 'ordered-list' : 'unordered-list',
          items: item.nested
        };
        parts.push(this.processList(nestedBlock, indent + 1));
      }
    }

    parts.push(`\\end{${env}}`);
    return parts.join('\n');
  }

  processTable(block) {
    const table = block?.data;
    if (!table) return '';

    const headers = Array.isArray(table.headers) ? table.headers : [];
    const rows = Array.isArray(table.rows) ? table.rows : [];

    const columnCount = Math.max(
      headers.length,
      ...rows.map(r => (Array.isArray(r) ? r.length : 0)),
      0
    );

    if (columnCount === 0) return '';

    const colSpec = '|' + Array.from({ length: columnCount }).map(() => 'X|').join('');
    const lines = [];

    lines.push('\\begin{tabularx}{\\linewidth}{' + colSpec + '}');
    lines.push('\\hline');

    if (headers.length > 0) {
      lines.push(this.renderTableRow(headers, columnCount) + ' \\\\');
      lines.push('\\hline');
    }

    for (const row of rows) {
      lines.push(this.renderTableRow(row, columnCount) + ' \\\\');
      lines.push('\\hline');
    }

    lines.push('\\end{tabularx}');
    return lines.join('\n');
  }

  renderTableRow(row, columnCount) {
    const cells = Array.isArray(row) ? row : [];
    const rendered = [];

    for (let i = 0; i < columnCount; i++) {
      const cell = cells[i];
      if (Array.isArray(cell)) {
        rendered.push(this.processInlineContent(cell, { preferInlineMath: true }));
      } else if (cell == null) {
        rendered.push('');
      } else {
        rendered.push(this.escapeLatexText(String(cell)));
      }
    }

    return rendered.join(' & ');
  }

  processInlineContent(content, options = {}) {
    if (!content || !Array.isArray(content)) return '';
    const preferInlineMath = Boolean(options.preferInlineMath);

    return content.map(element => {
      switch (element.type) {
        case 'text':
          return this.escapeLatexText(element.text || '');
        case 'bold':
          return `\\textbf{${element.content ? this.processInlineContent(element.content, options) : this.escapeLatexText(element.text || '')}}`;
        case 'italic':
          return `\\textit{${element.content ? this.processInlineContent(element.content, options) : this.escapeLatexText(element.text || '')}}`;
        case 'code':
          return `\\texttt{${this.escapeLatexText(element.text || '')}}`;
        case 'link':
          if (element.content) {
            return this.latexHref(
              element.href || '',
              this.processInlineContent(element.content, options),
              { displayIsLatex: true, displayRaw: element.text || '' }
            );
          }
          return this.latexHref(
            element.href || '',
            element.text || element.href || '',
            { displayIsLatex: false, displayRaw: element.text || '' }
          );
        case 'math-inline':
          return `$${(element.latex || '').trim()}$`;
        case 'math-block':
          if (preferInlineMath) {
            return `$${(element.latex || '').trim()}$`;
          }
          return `\\[\n${(element.latex || '').trim()}\n\\]`;
        default:
          return this.escapeLatexText(element.text || '');
      }
    }).join('');
  }

  splitInlineContent(content) {
    if (!content || !Array.isArray(content)) {
      return { text: '', mathBlocks: [] };
    }

    const mathBlocks = [];
    const textParts = [];

    for (const element of content) {
      if (element?.type === 'math-block' && element.latex) {
        mathBlocks.push(element.latex);
      } else if (element?.type === 'math-inline' && element.latex) {
        textParts.push(`$${element.latex}$`);
      } else {
        textParts.push(this.processInlineContent([element]));
      }
    }

    return { text: textParts.join(''), mathBlocks };
  }

  escapeLatexText(text) {
    if (text == null) return '';
    return String(text)
      .replace(/\r\n/g, '\n')
      .replace(/\\/g, '\\textbackslash{}')
      .replace(/([{}#$%&_])/g, '\\$1')
      .replace(/~/g, '\\textasciitilde{}')
      .replace(/\^/g, '\\textasciicircum{}')
      .replace(/\n/g, '\\\\\n');
  }

  escapeLatexUrl(url) {
    if (!url) return '';
    // Keep URL mostly intact; escape characters that will break TeX parsing.
    return String(url)
      .replace(/\s/g, '%20')
      .replace(/\\/g, '\\textbackslash{}')
      .replace(/([{}%#])/g, '\\$1');
  }

  latexHref(url, display, options = {}) {
    const safeUrl = this.escapeLatexUrl(url);
    const displayIsLatex = Boolean(options.displayIsLatex);
    const displayRaw = (options.displayRaw != null ? String(options.displayRaw) : String(display || ''));
    const displayValue = display || url || '';
    const displayLatex = displayIsLatex ? displayValue : this.escapeLatexText(displayValue);

    if (!safeUrl) {
      return displayLatex;
    }

    // If display text is the same as the URL, prefer \url{}.
    if (displayRaw.trim() === (url || '').trim()) {
      return `\\url{${safeUrl}}`;
    }

    return `\\href{${safeUrl}}{${displayLatex}}`;
  }

  getFilename() {
    const timestamp = new Date().toISOString().split('T')[0];
    const title = this.data.metadata.title || 'gemini-export';
    const sanitized = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 50);
    return `${sanitized}-${timestamp}.tex`;
  }

  static exportToLatex(data, options = {}) {
    const exporter = new LatexExporter(data, options);
    return {
      content: exporter.export(),
      filename: exporter.getFilename(),
      mimeType: 'application/x-tex'
    };
  }
}
